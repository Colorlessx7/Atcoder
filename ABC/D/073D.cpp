#include<bits/stdc++.h>
#include<atcoder/all>
using namespace atcoder;
using namespace std;
#define rep(i,N) for(ll i = 0; i < N; i++)
#define rep2(i,N) for(ll i = 1; i <= N; i++)
#define rep3(i,N) for(ll i = N - 1; i >= 0; i--)
#define rep4(i,N) for(ll i = N; i > 0; i--)
#define replr(i,l,r) for(ll i = l; i < r; i++)
#define reprl(i,l,r) for(ll i = l; i >= r; i--)
#define all(x) x.begin(),x.end() 
#define allr(x) x.rbegin(),x.rend() 
using ll = long long;
using P = pair<ll,ll>;
void chmin(ll &x, ll y){ x = min(x,y); }
void chmax(ll &x, ll y){ x = max(x,y); }
int main(){
  //入力部
  //n:町(頂点数),m:双方向に移動可能な道の数(辺)
  //R:訪れたい街の数(順列全探索の順列を構成する要素)
  ll n, m, R;
  cin >> n >> m >> R;
  //訪れたい街の頂点番号を入力
  vector<ll> r(R);
  rep(i,R){
    cin >> r[i];
    //グラフは0indexedなので-1
    r[i]--;
  }
  //d:隣接行列の形の無向グラフでd[i][j]でiからjへの移動にかかるコストを示す
  //(i,j)でiからjへの有向辺を示し、
  //d[i][j],d[j][i]の同頂点間の二本により双方向に結ばれた無向グラフであることを示す
  vector<vector<ll>> d(n,vector<ll>(n));
  //グラフの最短移動距離を初期化するために大きい値で設定
  const ll INF = 1001001001;
  rep(i,n){
    rep(j,n){
      //i=jなら同じ頂点を開始点、終了点としているため最短移動距離は0
      if(i == j){
        d[i][j] = 0;
      }else {
        //別の頂点間を結ぶ辺であるならば最短移動距離を無限で初期化
        d[i][j] = INF;
      }
    }
  }
  //入力で与えられる辺の設定
  rep(i,m){
    ll a, b, c;
    cin >> a >> b >> c;
    //グラフの頂点番号の0indexed調整
    a--; b--;
    //頂点aから頂点bへの最短移動距離をcに設定
    d[a][b] = c;
    //頂点bから頂点aへの最短移動距離をcに設定
    d[b][a] = c;
  }
  //ワーシャルフロイド処理
  //始点、中継地、終点についての全探索を行なっている
  //k:中継点
  //kをいちばん外側でループさせることで、一度のループで最短経路を計算できるようになる
  //仮にiを外側としてループを回した場合、0番目でスタートするものの計算を終えてから
  //1番目をスタートするもの、というように計算が移っていきます。
  //0番目のループで0→5→3という進み方が最短となったとして、
  //5番目を計算したら5→3にもっと短いルートが見つかったとなっても、
  //すでに計算済みの0→3にフィードバックされることがないのでkを外側でループさせる
  rep(k,n){
    //i:開始点
    rep(i,n){
      //j:終了点
      rep(j,n){
        //これまでのi,jの最短経路よりi,jの間に中継点kを挟んだ時の方が最短経路となるなら更新
        chmin(d[i][j],d[i][k] + d[k][j]);
      }
    }
  }
  //順列全探索のためsort(sortしないと順列の途中のパターンから始まってしまう)
  sort(all(r));
  //ans:全パターンの中の最短移動距離 minを取るため大きい値にしておく
  ll ans = INF;
  //順列rによる順列全探索
  do{
    //順列のパターンごとの最短移動距離
    ll sm = 0;
    //全頂点から全頂点への最小コストをワーシャルフロイドで求めたので
    //実質的に訪れたい頂点rのr[i]-r[i+1]だけを全部繋げた一本道のグラフ
    //として扱うことができる(その時の辺の本数はR-1となるためR-1回ループを回す)
    rep(i,R-1){
      //r[i]~r[i+1]に移動したときにかかるコストをsmにたす(rは順列全探索で順番が変わる)
      sm += d[r[i]][r[i+1]];
    }
    //smが最小を更新したならansに格納し更新
    chmin(ans,sm);
  }while(next_permutation(all(r)));
  //答えの出力
  cout << ans << endl;
  return 0;
}
//ワーシャルフロイド法で各頂点から別の各頂点に行く最短距離を全て求めて
//順列全探索をする問題
//重み付きグラフの最短経路問題を求めるためのアルゴリズムは
//ダイクストラ法とワーシャルフロイド法の2種類が存在するが
//ダイクストラ法はある頂点xのみから各頂点へ向かうルートの最短距離をO(ElogV)で求めるもので、
//ワーシャルフロイド法は全頂点から全頂点への最短経路をO(N^3)で求めるもので
//今回は順列全探索でこの順番に頂点を回ることを決めた時の最短経路とその距離を持ちたいので
//ワーシャルフロイド法を使う

//ワーシャルフロイド法は重み付きグラフ問題における最短経路を求めるアルゴリズムで
//動的計画法の一種である
