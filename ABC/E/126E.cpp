#include<bits/stdc++.h>
#include<atcoder/all>
using namespace atcoder;
using namespace std;
#define rep(i,N) for(ll i = 0; i < N; i++)
#define rep2(i,N) for(ll i = 1; i <= N; i++)
#define rep3(i,N) for(ll i = N - 1; i >= 0; i--)
#define rep4(i,N) for(ll i = N; i > 0; i--)
#define replr(i,l,r) for(ll i = l; i < r; i++)
#define reprl(i,l,r) for(ll i = l; i >= r; i--)
#define all(x) x.begin(),x.end() 
#define allr(x) x.rbegin(),x.rend() 
using ll = long long;
using P = pair<ll,ll>;
void chmin(ll &x, ll y){ x = min(x,y); }
void chmax(ll &x, ll y){ x = max(x,y); }
int main(){
  ll n, m;
  cin >> n >> m;
  //unionfind
  //片方が分かればもう片方がわかる連結成分のリスト
  dsu d(n);
  rep(i,m){
    ll x, y, z;
    cin >> x >> y >> z;
    //0indexed調整
    x--; y--;
    //片方が分かればもう片方もわかるのでx-yに辺を張る
    d.merge(x,y);
  }
  //無向グラフの連結成分について、1つでも数がわかれば全ての数が特定できる
  //そのため連結成分の数が答えとなる
  ll ans = d.groups().size();
  cout << ans << endl;
  return 0;
}
//unionfindで解く問題(グラフ問題に落とし込むまでが難しい)
//問題文でm個与えられる情報がAx+Ay+Z=0(mod2)というもので
//移項するとAx+Ay=-Zで偶奇を見るのでAx+Ay=Zとなって
//これによりAx+Ayが偶数か奇数かという情報がm個与えられるようになる
//Aの値が1か2(0として扱う)しか取らないことと
//矛盾した入力がこないことからAx,Ayのどちらかが分かれば両方わかるといえる
//そのためm回与えられたx,yで辺を張って最後に連結成分の個数を答えれば良い

//この発想はAx+Ay=Zという式を見たときに
//Zは入力なので係数のない変数が2つの式として見れて
//移項するとAx+Z=Ayとなりこのような式はグラフで考えるのが定石らしい
//グラフの形はAxという頂点からコストZでAyという頂点に辿り着ける形となる

//入力で矛盾が生じる可能性があり、矛盾があるなら-1を出力しろという問題だった場合
//Zが奇数1しかない場合は2部グラフ(グラフを2色に分けて塗ったときに隣接した辺が同じ色にならないグラフ)
//かどうかbfsで調べて、2部グラフなら連結成分の数を答える問題になる
//(色の配列を用意して全頂点をあらかじめ-1で初期化して
//最初の頂点を0として、そこから1回で行ける頂点を1として、010101と更新させていって
//途中て塗った頂点を他の頂点からたどり着いたときに見る過程で1で塗らないといけない頂点が
//0で塗られているような状態になったときに矛盾があったことになり-1を出力させる)
//Zが1,0の両方の可能性がある場合は
//最初にある頂点の色を決めて辺がZ=0でつながっているときは同じ色で塗り、
//Z=1で辺がつながっている時は違う色で塗るという動作を繰り返して
//すでに塗った頂点を別の頂点から塗り直す過程でZの偶奇によって矛盾が生じて違う色で塗り直す
//ような事態が起きたら矛盾しているので-1を出力するというのをbfsでやれば良い
//つまり2部グラフ判定が組めれば矛盾ありverを解くことができる
