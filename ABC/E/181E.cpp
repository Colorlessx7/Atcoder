#include<bits/stdc++.h>
#include<atcoder/all>
using namespace atcoder;
using namespace std;
#define rep(i,N) for(ll i = 0; i < N; i++)
#define rep2(i,N) for(ll i = 1; i <= N; i++)
#define rep3(i,N) for(ll i = N - 1; i >= 0; i--)
#define rep4(i,N) for(ll i = N; i > 0; i--)
#define replr(i,l,r) for(ll i = l; i < r; i++)
#define reprl(i,l,r) for(ll i = l; i >= r; i--)
#define all(x) x.begin(),x.end() 
#define allr(x) x.rbegin(),x.rend() 
using ll = long long;
using P = pair<ll,ll>;
void chmin(ll &x, ll y){ x = min(x,y); }
void chmax(ll &x, ll y){ x = max(x,y); }
int main(){
  ll n, m;
  cin >> n >> m;
  vector<ll> h(n),w(m);
  rep(i,n){
    cin >> h[i];
  }
  rep(i,m){
    cin >> w[i];
  }
  //児童の身長について昇順に並び替えた場合が隣接した生徒でペアを組んだ場合の
  //最適解となるので事前にsortしておく
  sort(all(h));
  const ll INF = 1e18;
  //今回の問題で先生とペアを組む児童を決めたときにコストを最小化する過程で
  //先生の身長について二分探索して求める
  //その方法は児童の身長以上の最小の値と児童の身長の値の差と
  //児童の身長の値と児童の身長未満の最大の値の差の小さい方を選べば良いが、
  //先生の身長の候補について児童の身長以上の最小の値と
  //児童の身長未満の最大の値のどちらかが偏った結果ない場合配列外参照を起こすので
  //-無限と+無限を先生の身長に追加する(コストが大きくなるので当然採用されない)
  w.push_back(-INF);
  w.push_back(INF);
  //先生の身長について二分探索するために事前にsortしておく
  sort(all(w));
  //ds[i]:前からi番目まで見た時の点数の合計
  //dt[i]:後ろからi番目まで見た時の点数の合計
  vector<ll> ds(n),dt(n);
  //前計算処理部分(ds)
  {
    //前から見た時のi番目の時点での点数の合計
    ll now = 0;
    rep(i,n){
      //配列は0,1,2,3,4,5が偶奇偶奇偶奇と並んでいて、
      //左から2つずつの差分を点数に足していくため
      //点数が変化するのが配列の添字iが奇数の時だけなのでその場合のみ処理
      if(i % 2 == 1){
        //sortした後の隣接する数字の差分を合計に追加
        //h[1]-h[0],h[3]-h[2]のようになる
        now += abs(h[i] - h[i-1]);
      }
      //i番目までの前から見た時の点数の合計にnowを格納
      ds[i] = now;
    }
  }
  //前計算処理部分(dt)
  {
    //後ろから見た時のi番目の時点での単数の合計
    ll now = 0;
    //
    rep(i,n){
      ll ni = n - 1 - i;
      //点数が変化するのが配列の添字niが奇数の時だけなのでその場合のみ処理
      if(i % 2 == 1){
        //sortした後の隣接する数字の差分を合計に追加
        //h[4]-h[3],h[2]-h[1]のようになる
        now += abs(h[ni] - h[ni+1]);
      }
      //ni番目までの後ろから見た時の点数の合計にnowを格納
      dt[ni] = now;
    }
  }
  //ans:変身形態とペアの組み方を工夫した時のそれぞれのペアの身長の差の合計の最小
  //minをとるため大きい値で答えを初期化
  ll ans = INF;
  //先生とペアを組む児童n人に対して全て試す
  rep(i,n){
    //ある児童とペアを組んで、変身形態とペアの組み方を工夫した時の
    //ペアの身長の差の合計を今から計算する
    ll now = 0;
    {
      //ペアを組む児童の身長以上の先生の身長を指す添字jを二分探索で求める
      ll j = lower_bound(all(w),h[i]) - w.begin();
      //組ませる先生の身長の候補が二分探索で求められた児童の身長以上のものw[j]と
      //児童の身長より小さいものw[j-1]になるので、この二つと
      //児童の身長h[i]の差分を計算し、小さい方を先生-児童ペアのコストとする
      now += min(w[j] - h[i], h[i] - w[j-1]);
    }
    //先生-児童のペアは計算したので、選んだ児童より左側の児童ペアの
    //身長の差の合計ds[i]と、選んだ児童より右側の児童ペアの
    //身長の差の合計dt[i]を合計したものが身長の差の合計となる
    now += ds[i] + dt[i];
    //iが奇数の場合児童同士でペアを組むのに、iの左側と右側が
    //それぞれ奇数人しかいないためペアを組めず
    //選んだ児童の隣2人が溢れてしまうので
    //その溢れた2人でペアを組ませてその差をスコアとしてnowに加算する
    //ただ、こうした場合児童を挟んだペアになるため身長の差が大きくなり、
    //先生と奇数番目の児童を組ませるのは身長の差の合計が最適解にならないため
    //この処理は要らなくて、そもそも偶数番目の児童にのみ先生とペアを組ませるように
    //処理させればいいだけだった
    if(i % 2 == 1){
      now += abs(h[i-1] - h[i+1]);
    }
    //ある児童とペアを組んだ場合のペアの身長の差を計算しきったので
    //最小値だったか検証し最小ならansに格納
    ans = min(ans, now);
  }
  cout << ans << endl;
  return 0;
}
//貪欲法で解く問題を二分探索によって高速化して解く問題
//解法は複数あり、1つは先生の身長を試した時のコストを高速に求める方法
//やり方は先生が挿入される位置を二分探索で求めて
//そこに入れた時のコストをO(1)で前計算しておくことで高速に求めることができる
//今回のは逆に先生の挿入位置(先生と組む人)について全て試して、その時のコストの求め方は
//先生を挿入する位置以外のコストを前計算で求めて
//先生とペアを組む人のコストを先生の身長について二分探索してコストが一番小さくなる
//先生の身長を求めることでコストの総計算を高速化する方法を使っている
//
