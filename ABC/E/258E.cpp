#include<bits/stdc++.h>
#include<atcoder/all>
using namespace atcoder;
using namespace std;
#define rep(i,N) for(int i = 0; i < N; i++)
#define rep2(i,N) for(int i = 1; i <= N; i++)
#define rep3(i,N) for(int i = N - 1; i >= 0; i--)
#define rep4(i,N) for(int i = N; i > 0; i--)
#define replr(i,l,r) for(int i = l; i < r; i++)
#define reprl(i,l,r) for(int i = l; i >= r; i--)
#define all(x) x.begin(),x.end() 
#define allr(x) x.rbegin(),x.rend() 
using ll = long long;
using P = pair<int,int>;
using TP = tuple<int,int,int>;
void chmin(int &x, int y){ x = min(x,y); }
void chmax(int &x, int y){ x = max(x,y); }
int main(){
  //n:じゃがいもの重さの配列wの1周期の長さ
  //q:クエリ数,x:箱に蓋をする重さの条件
  int n, q, x;
  cin >> n >> q >> x;
  //w[i]:1周期のi番目のじゃがいもの重さ
  vector<int> w(n);
  rep(i,n){
    cin >> w[i];
  }
  //s:一周期のジャガイモの重さの合計(0初期化)
  ll s = 0;
  //合計を計算
  rep(i,n){
    s += w[i];
  }
  //rd:何周するか(rd周期分全部箱に詰めてもまだ余裕があるかの最大(rd*s<x))
  ll rd = x/s;
  //rem:rd周分箱に詰めた時のその箱に入れられる残りの重量(remはs未満)
  ll rem = x%s;
  //a[i]:i番目のじゃがいもから箱に詰めていった時に何個のじゃがいもを
  //詰めた時点で箱の重さがxを超えるか
  vector<ll> a(n);
  //i番目のじゃがいもから箱に詰めていった時に何個のじゃがいもを
  //詰めた時点で箱の重さがxを超えるかのカウンタ
  //(初期化は1周期分のジャガイモの個数n*周期rd(rd周期のジャガイモの総数))
  ll na = rd*n;
  //尺取法O(N)
  //Xが極端に大きく、sが極端に小さい場合などに普通にやると何周期分もループが回ってしまい
  //計算量が爆発するため、すでにrd周期分のジャガイモrd*nを全ての箱に入れたと仮定して、
  //それらの箱の余りの重量だけを見て尺取法をすることでO(N)でできる
  rep(i,n){
    //箱に入れられる残りの重量が許す限り処理
    while(rem >= 1){
      //次のジャガイモの番号が(i+na)%nとなる
      //箱に入れられる残りの重量から次のジャガイモの重さをひく
      rem -= w[(i+na)%n];
      //箱にジャガイモを入れたので個数のカウンタを進める
      na++;
    }
    //i番目のじゃがいもから箱に入れた場合の箱の中のじゃがいもの数がnaになったので格納する
    a[i] = na;
    //i+1番目(次)のじゃがいもから考えるので範囲外となったi番目のじゃがいもの重さを
    //箱に入れられる残りの重量に加算
    rem += w[i];
    //i+1番目のじゃがいもから箱に詰めていく場合i番目のじゃがいもを箱に入れないので
    //個数のカウンタを-1する
    na--;
  }
  //配列サイズがDなら最後のindexはD-1になる
  //2^(D-1)がKの制約の10^12を超える最初の値Dを配列サイズとする
  const int D = 41;
  //ダブリング用の配列
  //d[i][j]:2^i回の遷移(箱詰め)をj番目のじゃがいもから行うとき、
  //その遷移以降の最初の箱に詰めるじゃがいもは何番目のじゃがいもからか
  vector d(D,vector<int>(n));
  //ダブリング配列の初期化
  //2^0=1回遷移が起きた時の移動先をd[0][i]に格納(1回の遷移の有向辺を張る)
  rep(i,n){
    //a[i]:i番目のじゃがいもから箱に入れていくとその箱に何個じゃがいもが入るか
    //(i+a[i])%nで次の箱に最初に入るじゃがいものindexが求まる(iから(i+a[i])%nへの有向辺を張る)
    d[0][i] = (i+a[i])%n;
  }
  //ダブリングのdp配列埋め
  //残りのD(1~D-1)について埋める処理
  rep(i,D-1){
    //全ての頂点について処理
    rep(j,n){
      //ダブリングの2^(i+1)の遷移は2^iの遷移の有向辺2つを辿ったものになる
      //dp[i+1][j]はnew_j=dp[i][j]とした時のdp[i][new_j]となる
      //(jからdp[i][j]に有向辺で遷移し、dp[i][j]からdp[i][dp[i][j]]に有向辺で遷移する)
      d[i+1][j] = d[i][d[i][j]];
    }
  }
  //クエリ処理O(QlogK)
  rep(_,q){
    //箱の番号
    ll k;
    cin >> k;
    //最初の頂点siが1つ目の箱の先頭の頂点であり、k回遷移するとsiはk+1番目の箱の先頭の頂点になる
    //求めたいのはk番目の箱の先頭の頂点なのでk-1回の遷移でk番目の箱の先頭の頂点を得るために-1する必要がある
    k--;
    //si:k-1回遷移(k-1個箱詰め)した後の次の箱の最初のじゃがいもが何番目か
    //必ず先頭のじゃがいもから箱に詰めるので0初期化
    int si = 0;
    //kを2進数変換した時の上の位から処理
    //ダブリングの処理としてx=22とすると2進数に変換して10110となり、
    //bitが立っているのが16,4,2(2^4,2^2,2^1)の位なので、
    //その立っているbitの遷移を全て1回ずつ行うことによりx回の遷移を行ったことになる
    rep3(i,D){
      //kのi桁目のbitが立っているなら処理
      if(k >> i&1){
        //siを今いる頂点siから2^i回遷移した先の頂点d[i][si]に変更
        si = d[i][si];
      }
    }
    //a[si]:si番目のじゃがいもから箱に詰めた時のその箱のじゃがいもの個数なのでそれを出力
    printf("%lld\n",a[si]);
  }
  return 0;
}
//尺取法とダブリング解
//w={3,1,4,2,4},x=7だと
//箱は、{3,1,4},{2,4,3},{1,4,2},{4,3},{1,4,2},{4,3},...となる
//箱の最初のindexと、次の箱の最初のindexに着目すると
//0,3,1,4,1,4...となる。前の箱の最初のindexから次の箱の最初のindexへの有向辺を張ると
//ダブリングでk番目の箱に最初に入るじゃがいものindexがわかる
//尺取法で逆にi番目のじゃがいもから箱に入れた時の何個箱に入るかを求めておけば
//前処理O(N),クエリ解答O(QlogK)で求めることができる
