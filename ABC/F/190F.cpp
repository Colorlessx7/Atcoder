#include<bits/stdc++.h>
#include<atcoder/all>
using namespace atcoder;
using namespace std;
#define rep(i,N) for(ll i = 0; i < N; i++)
#define rep2(i,N) for(ll i = 1; i <= N; i++)
#define rep3(i,N) for(ll i = N - 1; i >= 0; i--)
#define rep4(i,N) for(ll i = N; i > 0; i--)
#define replr(i,l,r) for(ll i = l; i < r; i++)
#define reprl(i,l,r) for(ll i = l; i >= r; i--)
#define all(x) x.begin(),x.end() 
#define allr(x) x.rbegin(),x.rend() 
using ll = long long;
using P = pair<ll,ll>;
void chmin(ll &x, ll y){ x = min(x,y); }
void chmax(ll &x, ll y){ x = max(x,y); }
int main(){
  ll n;
  cin >> n;
  vector<ll> a(n);
  rep(i,n){
    cin >> a[i];
  }
  ll ans = 0;
  //fenwick_treeのコンストラクタ
  //型がllの長さnの配列a0,a1,...,an-1を作る(初期値は全て0初期化)
  //今回のような転倒数を求める処理はBITの値は0,1のどちらかしかない
  //BITで転倒数を求める時のBITの中身は数列を左から見ていくとして
  //1:すでに登場した数字(今回はa[i]),0:まだ登場していない数字となる
  fenwick_tree<ll> t(n);
  //BITで問題文のk=0の時の転倒数を求める処理
  rep(i,n){
    //sum(l,r)でBITの[l,r-1]の区間の合計を計算する
    //今見ている数列の数字a[i]より大きい数字が既に出てきた数を転倒数に足す
    //BIT上の区間[a[i],n-1]の1になっているものの添字が数列にすでに出てきた数字に対応
    ans += t.sum(a[i],n);
    //add(a,b)でBITのa番目の値にbを足す
    //a[i]が登場したのでBIT上のa[i]番目のフラグを立てる
    t.add(a[i],1); 
  }
  //kを可変させた時の転倒数の変化を計算し出力
  rep(k,n){
    cout << ans << endl;
    //数列の先頭のa[i]を削除したときの転倒数の変化
    //転倒数の性質より先頭のa[i]を削除すると数列の残りの部分のa[i]未満の数字の個数分
    //転倒数が減る(例の場合なら、a[i]=0なら数列の右側に
    //より小さい数字が存在しないため転倒数は変化なし、
    //a[i]=1なら数列の残りの部分が0の場合だけ
    //先頭の数字の方が大きくなるから転倒数が1つ減る...と考えると先頭の数字の内容分
    //転倒数が減少するので以下の式のようになる)
    ans -= a[k];
    //数列の末尾にa[i]を追加した時の転倒数の変化
    //上と逆に末尾に追加したa[i]より大きな値が追加したa[i]の左側にある
    //数だけ転倒数が増加する(例の場合なら、a[i]=9なら左側に
    //より大きい数字が存在しないため転倒数は変化なし
    //a[i]=8なら数列の左側が9の場合だけ末尾の数字のほうが小さくなるから
    //転倒数が1増える...と考えると末尾となる数字をn-1から引いた分
    //転倒数が増えるため以下の式のようになる)
    ans += n-1-a[k];
  }
  return 0;
}
//Binary Indexed Tree (fenwick_tree)を使って転倒数を求める問題
//転倒数を求める方法についての説明を以下に記す
//例として0,3,1,5,4,2,9,6,8,7の数列を考える
//fenwick_treeでの動作は以下のようになる
//a[i]   i ans tree
//     def   0 [0,0,0,0,0,0,0,0,0,0]
//   0   0   0 1,0,0,[0,0,0,0,0,0,0] 0は先頭なので左側のより大きい数字は0
//   3   1   0 1,[0,0,1,0,0,0,0,0,0] 3の左側のより大きい数字は0
//   1   2   1 1,1,0,1,0,[0,0,0,0,0] 1の左側のより大きい数字は1つ(3)
//   5   3   1 1,1,0,1,[0,1,0,0,0,0] 5の左側のより大きい数字は0
//   4   4   2 1,1,[0,1,1,1,0,0,0,0] 4の左側のより大きい数字は1つ(5)
//   2   5   5 1,1,1,1,1,1,0,0,0,[0] 2の左側のより大きい数字は3つ(3,4,5)
//   9   6   5 1,1,1,1,1,1,[0,0,0,1] 9の左側のより大きい数字は0
//   6   7   6 1,1,1,1,1,1,1,0,[0,1] 6の左側のより大きい数字は1つ(9)
//   8   8   7 1,1,1,1,1,1,1,[0,1,1] 8の左側のより大きい数字は1つ(9)
//   7   9   9 1,1,1,1,1,1,1,1,1,1   7の左側のより大きい数字は2つ(8,9) 
//という処理が行われ転倒数ans=9となる
//転倒数を求めるときは数列を左から1つずつ見ていくときに
//数字一つ毎にその数字より大きい数字が数列の見ている数字の左側に何個あるか
//を集計する作業を数列の数字一つ毎に行なった結果がその数列の転倒数となる
//転倒数の最大パターンは降順に全て並んでいる時で
//転倒数の数はnC2で求まる(今回はn=3*10^5でnC2=4.5e10になるためllでないとWAとなる)
