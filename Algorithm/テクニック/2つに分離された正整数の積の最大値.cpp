//ABC221Cより 整数Nが与えられ,Nの各桁の数字を取り出して並べ(並べる順序は好きに変えてよい2つの正整数に分離した時のその積の最大値

#include<bits/stdc++.h>
#include<atcoder/all>
using namespace atcoder;
using namespace std;
#define rep(i,N) for(int i = 0; i < N; i++)
typedef long long ll;
int main(){
    int n1;
    cin >> n1;
    string n = to_string(n1);
    //Nを文字列として降順にソートする
    sort(n.rbegin(),n.rend());
    int x = n.size();
    string a;
    string b;
    //Nの先頭から奇数文字目からなる文字列をA偶数文字目からなる文字列をBとする
    rep(i,x){
        if(i % 2 == 0){
            a += n[i];
        }
        if(i % 2 == 1){
            b += n[i];
        }
    }
    //A,Bを先頭から見て、初めて異なる文字が登場する箇所について、その2文字を入れ替える
    rep(i,x / 2){
        if(a[i] != b[i]){
            swap(a[i],b[i]);
            break;
        }
    }
    //A,Bを整数とみなしA×Bを出力する
    int an = stoi(a);
    int bn = stoi(b);
    int ans = an * bn;
    cout << ans << endl;
    return 0;
}
/*次のようなアルゴリズムで答えを求めることができます。
Nを文字列として降順にソートする
Nの先頭から奇数文字目からなる文字列をA偶数文字目からなる文字列をBとする
A,Bを先頭から見て、初めて異なる文字が登場する箇所について、その2文字を入れ替える
A,Bを整数とみなしA×Bを出力する
2行目まで分かっていたが3行目がやや違っていた */

/*証明は
①　2 数の桁数の差が 2 以上であるとき、桁数が大きい方の末尾の数字を桁数が小さい方の末尾に移動してよい
例：1001×99 は 100×991 にしてよい
②　2 数に使う文字集合を固定した場合は、それぞれ降順に使うのが最適
例：N=123456 をもし {1,3,4},{2,5,6} と分けるなら、431×652 としてよい
③　②より N の桁数が奇数なら、0 を 1 つ追加し最後に答えを 10 で割るとしてよいので、N が偶数桁の場合のみ考えればよい。したがって①より、2 数は桁数が等しいとしてよい
④　もし他方の数の上位により小さい数があるなら、入れ替えてよい
例：6542×8760 は6542 の百の位の 5 が 8760 の十の位の 6 より小さいので入れ替えて、6642×8750 としてよい
⑤　③と④により、考えるべき 2 数の組み合わせは和が一定であるので、積が最大となるのは差が最小となるときである。したがって冒頭のアルゴリズムで答えを得ることができる
