Q2 二次元配列dpの触り
  2-1
  問題傾向 表埋め 連続計算
  テーブル dp[i][j]:座標(i,j)の値
  サイズ dp(4,vector<int>(4))
  初期値 dp[0][0,1,2,3]の4つ = 入力
  漸化式 dp[i][j] += dp[i-1][j-1] (j != 0)
        dp[i][j] += dp[i-1][j]
        dp[i][j] += dp[i-1][j+1] (j != 3)
  最終出力 dp[3][3]
  
  2-2
  問題傾向 表埋め 連続計算
  テーブル dp[i][j]:座標(i,j)の値
  サイズ dp(4,vector<int>(4))
  初期値 dp[0][0,1,2,3]の4つ = 入力
  漸化式 dp[i][j] += dp[i-1][j-1] (j != 0)
        dp[i][j] += dp[i-1][j]
        dp[i][j] += dp[i-1][j+1] (j != 3)
        dp[i][j] %= 100
  最終出力 dp[3][3]
  
  2-3
  問題傾向 連続不可の仕事選び
  テーブル dp[i][j]:i日目にj番目の仕事を選んだ時のi日目までの報酬
  サイズ dp(n+1,vector<int>(3))
  初期値 全て 0
  漸化式 dp[i][0] += max(dp[i-1][1],dp[i-1][2]) + a[i-1][0]
        dp[i][1] += max(dp[i-1][2],dp[i-1][0]) + a[i-1][1]
        dp[i][2] += max(dp[i-1][0],dp[i-1][1]) + a[i-1][2]
        (aは仕事の報酬)
  最終出力 max(dp[n][0],max(dp[n][1],dp[n][2]))
  
  2-4
  問題傾向 道順のパターン数の数え上げ
  テーブル dp[i][j]:上からi行目、左からj列目のマスにたどり着くまでの道順の個数
  サイズ dp(n,vector<int>(n))
  初期値 dp[0][0~n-1],dp[0~n-1][0] = 1
  漸化式 dp[i][j] += dp[i-1][j] + dp[i][j-1]
  最終出力 dp[n-1][n-1]
  
  2-5
  問題傾向 道順のパターン数の数え上げ(障害物あり)
  テーブル dp[i][j]:上からi行目、左からj列目のマスにたどり着くまでの道順の個数
  サイズ dp(n,vector<int>(n))
  初期値 dp[0][0~n-1],dp[0~n-1][0]の障害物の1つ前まで = 1
  漸化式 dp[i][j](障害物の場所) = -1
        dp[i][j] += dp[i-1][j] + dp[i][j-1](障害物が関係する場合-1初期化なので調整必要)
  最終出力 dp[n-1][n-1]
  
  2-6
  問題傾向 数値最大化 
  テーブル dp[i][j]:上からi行目、左からj列目のマスにたどり着いた時のこれまでの数値の総和の最大値
  サイズ dp(n,vector<int>(n))
  初期値 dp[0][0] = a[0][0](aは入力した配列)
  漸化式 dp[i][0] += dp[i-1][0] + a[i][0] (i!=0,漸化式ではあるが初期値)
        dp[0][j] += dp[0][j-1] + a[0][j] (j!=0,漸化式ではあるが初期値)
        dp[i][j] = max(dp[i-1][j],dp[i][j-1]) + a[i][j]
  最終出力 dp[n-1][n-1]
  
  2-7
  問題傾向 数値最小化 
  テーブル dp[i][j]:上からi行目、左からj列目のマスにたどり着いた時のこれまでの数値の総和の最小値
  サイズ dp(n,vector<int>(n))
  初期値 dp[0][n-1] = a[0][n-1](aは入力した配列)
  漸化式 dp[i][n-1] += dp[i-1][n-1] + a[i][n-1] (i!=0,漸化式ではあるが初期値)
        dp[0][j] += dp[0][j+1] + a[0][j] (j!=n-1,漸化式ではあるが初期値,jはn-1から0へ向かってループ)
        dp[i][j] = min(dp[i-1][j],dp[i][j+1]) + a[i][j]
  最終出力 dp[n-1][0]
